# 从整理扑克牌到字母异位词分组：一道巧妙的排序应用题

## 生活中的算法
你有没有玩过扑克牌？打完一局之后，我们通常会把散落的牌收集起来，按照花色分组整理。虽然每张牌的花色图案位置可能不同，但只要是同一个花色，我们就把它们放在一起。

这和我们今天要讲的"字母异位词分组"问题很像。字母异位词就像是同一花色的扑克牌，它们由相同的字母组成，只是字母的排列顺序不同。

## 问题描述
LeetCode第49题"字母异位词分组"是这样描述的：给你一个字符串数组，请你将所有的字母异位词放在同一个组里。字母异位词是由相同的字母重新排列组成的单词。

例如，"eat"、"ate"和"tea"就是字母异位词，因为它们都由字母'a'、'e'、't'组成，只是排列顺序不同。

## 最直观的解法：排序比较法
如何判断两个单词是否是字母异位词？最直观的方法就是：把两个单词的字母都排序后比较，如果排序后相同，那就是字母异位词。

就像整理扑克牌时，我们会把每张牌的花色符号位置摆正，这样就容易看出它们是不是同一花色。

具体步骤是这样的：
1. 对于每个单词，将其字符排序得到一个标准形式
2. 使用这个标准形式作为key，原单词作为value，存入哈希表
3. 具有相同key的单词就是字母异位词，将它们分到同一组

让我们用一个例子来模拟这个过程：
```
输入：strs = ["eat","tea","tan","ate","nat","bat"]

处理"eat"：
- 排序后是"aet"
- 哈希表：{"aet": ["eat"]}

处理"tea"：
- 排序后是"aet"
- 找到已有的组，添加进去
- 哈希表：{"aet": ["eat","tea"]}

处理"tan"：
- 排序后是"ant"
- 创建新组
- 哈希表：{"aet": ["eat","tea"], "ant": ["tan"]}

...以此类推
```

这种思路可以用Java代码这样实现：
```java
public List<List<String>> groupAnagrams(String[] strs) {
    // 创建哈希表，key是排序后的字符串，value是原字符串列表
    Map<String, List<String>> map = new HashMap<>();
    
    for (String str : strs) {
        // 将字符串转换为字符数组并排序
        char[] chars = str.toCharArray();
        Arrays.sort(chars);
        // 将排序后的字符数组转回字符串，作为key
        String key = new String(chars);
        
        // 如果key不存在，创建新的列表
        if (!map.containsKey(key)) {
            map.put(key, new ArrayList<>());
        }
        // 将原字符串添加到对应的组
        map.get(key).add(str);
    }
    
    // 返回所有分组的列表
    return new ArrayList<>(map.values());
}
```

## 优化解法：计数法
还有一种更巧妙的解法。如果我们仔细观察，会发现：字母异位词的特点是每个字母出现的次数相同。

就像数纸牌时，我们不需要真的把牌排序，只需要数一下每种花色各有多少张。

### 计数法的原理
1. 对于每个单词，统计其中每个字母出现的次数
2. 将这个统计结果作为key（需要特殊的格式化方式）
3. 相同统计结果的单词就是字母异位词

### 算法步骤（伪代码）
1. 创建哈希表map存储分组结果
2. 对于每个单词：
   - 创建一个大小为26的计数数组
   - 统计每个字母的出现次数
   - 将计数数组转换为特殊格式的字符串作为key
   - 将单词加入对应的分组
3. 返回所有分组

### 示例运行
让我们模拟处理输入：["eat", "tea", "tan"]
```
处理"eat"：
- 计数：{a:1, e:1, t:1, 其他:0}
- key = "1#1#0#0#1#0#..."（代表a1b0c0d0e1...）
- 创建新组：{"1#1#0#0#1#0...": ["eat"]}

处理"tea"：
- 计数相同：{a:1, e:1, t:1, 其他:0}
- 找到相同的key，加入该组
- {"1#1#0#0#1#0...": ["eat","tea"]}

处理"tan"：
- 计数：{a:1, n:1, t:1, 其他:0}
- 新的key，创建新组
- map添加新组
```

### Java代码实现
```java
public List<List<String>> groupAnagrams(String[] strs) {
    // 创建哈希表存储分组
    Map<String, List<String>> map = new HashMap<>();
    
    for (String str : strs) {
        // 创建字符计数数组
        int[] count = new int[26];
        // 统计每个字符出现的次数
        for (char c : str.toCharArray()) {
            count[c - 'a']++;
        }
        
        // 构建key
        StringBuilder key = new StringBuilder();
        for (int i = 0; i < 26; i++) {
            key.append(count[i]).append('#');
        }
        String keyStr = key.toString();
        
        // 添加到对应的分组
        if (!map.containsKey(keyStr)) {
            map.put(keyStr, new ArrayList<>());
        }
        map.get(keyStr).add(str);
    }
    
    return new ArrayList<>(map.values());
}
```

## 排序法vs计数法
让我们比较这两种解法：

排序法的时间复杂度是O(nklogk)，其中n是单词数量，k是最长单词的长度。主要时间花在对每个单词进行排序上。它的优点是直观易懂，而且如果单词长度不大，性能也不错。

计数法的时间复杂度是O(nk)，因为我们只需要遍历每个单词一次，统计字母出现次数。虽然实现稍微复杂一些，但在处理长单词时更有优势。

## 题目模式总结
这道题体现了一个重要的算法模式：**通过某种标准形式来对对象分组**。

这种模式在实际编程中经常出现，比如：
- 按文件大小分类存储文件
- 对用户行为数据进行分组分析
- 整理图书馆的图书分类

解决这类问题的通用思路是：
1. 设计一个合适的标准形式（可以是排序后的结果，也可以是某种统计特征）
2. 用哈希表存储分组结果
3. 选择合适的数据结构来表示标准形式（字符串、数组等）

## 小结
通过这道题，我们不仅学会了如何解决字母异位词分组问题，更重要的是理解了"标准形式分组"这一重要的算法思想。这种思想在很多实际问题中都能派上用场。

记住，写代码时多思考如何把问题抽象成更一般的模式，这样才能举一反三，提高解决问题的能力！

---
作者：忍者算法
公众号：忍者算法

我准备了一份刷题清单，以及这些题目的详细题解，覆盖了绝大部分常见面试题。我可以很负责任地说，只要你把这些题真正掌握了，80%的算法面试都能遇到相似题目。公众号回复【刷题清单】获取～