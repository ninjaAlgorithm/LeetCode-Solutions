# 从理房间到移动零：一道考察数组操作的经典题目

## 生活中的算法
你有没有整理过房间？常常会发现一些要丢掉的东西，但又不想立刻处理。这时候，我们通常会先把这些东西推到角落，把有用的东西集中在一起。等整理完后，再统一处理角落里的那些要丢弃的物品。

这就很像我们今天要讲的"移动零"问题：把数组中的零移到末尾，同时保持其他元素的相对顺序不变。就像整理房间时，我们把不要的东西（零）移到角落，同时保持其他物品（非零元素）的摆放顺序不变。

## 问题描述
LeetCode第283题"移动零"是这样描述的：给定一个数组nums，编写一个函数将所有0移动到数组的末尾，同时保持非零元素的相对顺序。要求必须在原数组上操作，不能使用额外的数组空间。

比如，输入：nums = [0,1,0,3,12]，处理后应该得到：[1,3,12,0,0]。

## 最直观的解法：两次遍历法
最容易想到的方法就是：先把所有非零元素按顺序排在数组前面，然后把剩下的位置都填上0。就像整理房间时，先把要留下的东西整理好，然后剩下的空间就是要清理的区域。

具体步骤是这样的：
1. 用一个指针记录当前应该放置非零元素的位置
2. 遍历数组，遇到非零元素就放到这个位置，并移动指针
3. 最后，从指针位置到数组末尾都填充0

让我们用一个例子来模拟这个过程：
```
原数组：[0,1,0,3,12]

第一次遍历（移动非零元素）：
pos = 0, 遇到0，跳过
pos = 0, 遇到1，放入pos位置：[1,1,0,3,12]，pos++
pos = 1, 遇到0，跳过
pos = 1, 遇到3，放入pos位置：[1,3,0,3,12]，pos++
pos = 2, 遇到12，放入pos位置：[1,3,12,3,12]，pos++

第二次遍历（填充0）：
从pos=3开始填充0：[1,3,12,0,0]
```

这种思路可以用Java代码这样实现：
```java
public void moveZeroes(int[] nums) {
    // 记录非零元素应该放置的位置
    int pos = 0;
    
    // 第一次遍历：放置非零元素
    for (int num : nums) {
        if (num != 0) {
            nums[pos] = num;
            pos++;
        }
    }
    
    // 第二次遍历：填充0
    while (pos < nums.length) {
        nums[pos] = 0;
        pos++;
    }
}
```

## 优化解法：单次遍历法
仔细观察可以发现，我们其实可以用一次遍历就完成任务。关键是用两个指针：一个指向当前应该放置非零元素的位置，另一个用来遍历数组。当遇到非零元素时，把它和前面的零交换位置。

### 单次遍历法的原理
1. 用左指针记录下一个非零元素应该放置的位置
2. 用右指针遍历数组
3. 当右指针遇到非零元素时，将其与左指针指向的位置交换
4. 左指针只有在处理非零元素时才移动

### 算法步骤（伪代码）
1. 初始化左指针left = 0
2. 遍历数组，右指针right从0到末尾：
   - 如果遇到非零元素
   - 交换left和right位置的元素
   - left指针右移
3. 完成后，所有零都在数组末尾

### 示例运行
让我们用示例数组[0,1,0,3,12]模拟运行过程：
```
初始状态：[0,1,0,3,12]，left=0，right=0

right=0：
- 遇到0，不操作

right=1：
- 遇到1，与left交换：[1,0,0,3,12]
- left移动到1

right=2：
- 遇到0，不操作

right=3：
- 遇到3，与left交换：[1,3,0,0,12]
- left移动到2

right=4：
- 遇到12，与left交换：[1,3,12,0,0]
- left移动到3

结束
```

### Java代码实现
```java
public void moveZeroes(int[] nums) {
    int left = 0;  // 记录下一个非零元素应放置的位置
    
    // 遍历数组
    for (int right = 0; right < nums.length; right++) {
        if (nums[right] != 0) {
            // 如果left和right不同，才需要交换
            // 这个优化可以减少不必要的自身交换
            if (left != right) {
                // 交换left和right位置的元素
                int temp = nums[left];
                nums[left] = nums[right];
                nums[right] = temp;
            }
            left++;
        }
    }
}
```

## 两次遍历vs单次遍历
让我们比较这两种解法：

两次遍历法的时间复杂度是O(n)，需要遍历两次数组。它的优点是逻辑简单清晰，容易理解和实现。

单次遍历法的时间复杂度也是O(n)，但只需要遍历一次数组。它通过巧妙的指针操作，一次遍历就完成了任务。虽然实现稍微复杂一些，但在实际运行时更高效。

两种方法的空间复杂度都是O(1)，因为都是在原数组上进行操作。

## 题目模式总结
这道题体现了一个重要的数组操作模式：**双指针技巧**。

这种技巧在数组操作中经常出现，比如：
- 删除数组中的重复元素
- 合并两个有序数组
- 判断是否是回文数组

解决这类问题的通用思路是：
1. 确定两个指针的用途（比如一个用于记录位置，一个用于遍历）
2. 明确指针移动的条件
3. 考虑元素交换或移动的时机

## 小结
通过这道题，我们不仅学会了如何高效地移动数组中的零元素，更重要的是掌握了双指针这一重要的编程技巧。这种技巧在处理数组问题时特别有用，能帮助我们写出更高效的代码。

记住，有时候看似简单的问题，通过巧妙的算法设计，能让解决方案变得更加优雅高效！

---
作者：忍者算法
公众号：忍者算法

我准备了一份刷题清单，以及这些题目的详细题解，覆盖了绝大部分常见面试题。我可以很负责任地说，只要你把这些题真正掌握了，80%的算法面试都能遇到相似题目。公众号回复【刷题清单】获取～