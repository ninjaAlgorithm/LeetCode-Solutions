# 从城市天际线到二叉树右视图：如何捕捉每层最右的风景

## 生活中的算法
想象你站在摩天大楼的右侧，想要记录每层楼最右边的窗户位置。当楼层从下往上排列时，每个楼层你只能看到最右侧的窗户。这个场景完美对应了今天要解决的算法问题——二叉树的右视图。

就像城市规划师需要确定天际线的轮廓一样，我们需要找到二叉树每一层最右侧的节点值。

## 问题描述
LeetCode第199题"二叉树的右视图"要求：给定一棵二叉树的根节点，返回从右侧观察这棵树时能看到的节点值列表。

例如，给定二叉树：
```
    1
   / \
  2   3
   \   \
    5   4
```
右侧视图结果为：[1, 3, 4]

## 最直观的解法：层序遍历法
就像用无人机逐层扫描大楼，我们可以使用广度优先搜索（BFS）逐层遍历二叉树，记录每层的最后一个节点。

### 算法步骤
1. 使用队列进行层序遍历
2. 记录每层节点数量
3. 将每层最后一个节点加入结果列表

示例运行过程：
```
层序遍历顺序：
第一层：1 → 最后一个节点是1
第二层：2→3 → 最后一个节点是3
第三层：5→4 → 最后一个节点是4
最终结果：[1,3,4]
```

Java实现：
```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        if (root == null) return result;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);

        while (!queue.isEmpty()) {
            int levelSize = queue.size();
            for (int i = 0; i < levelSize; i++) {
                TreeNode node = queue.poll();
                // 记录每层最后一个元素
                if (i == levelSize - 1) result.add(node.val);
                
                if (node.left != null) queue.offer(node.left);
                if (node.right != null) queue.offer(node.right);
            }
        }
        return result;
    }
}
```

## 优化解法：深度优先遍历法
如果大楼有快速通道可以直达顶层，何必逐层扫描？我们可以通过深度优先遍历（DFS）优先访问右子树，在首次到达新深度时记录节点值。

### 递归实现原理
1. 维护一个记录当前最大深度的变量
2. 优先遍历右子树
3. 当首次到达新深度时记录节点值

示例运行过程（示例树）：
```
递归路径：1→3→4（深度0→1→2）
然后回溯到3→1→2→5（深度1→0→1→2）
但深度2已被记录，不再更新
最终结果：[1,3,4]
```

Java代码：
```java
class Solution {
    List<Integer> result = new ArrayList<>();
    
    public List<Integer> rightSideView(TreeNode root) {
        dfs(root, 0);
        return result;
    }
    
    private void dfs(TreeNode node, int depth) {
        if (node == null) return;
        
        // 首次到达该深度时记录节点值
        if (depth == result.size()) {
            result.add(node.val);
        }
        
        // 优先访问右子树
        dfs(node.right, depth + 1);
        dfs(node.left, depth + 1);
    }
}
```

## 两种解法对比
| 方法               | 时间复杂度 | 空间复杂度 | 特点                     |
|--------------------|------------|------------|--------------------------|
| 层序遍历（BFS）    | O(n)       | O(n)       | 直观易懂，适合层相关操作 |
| 深度优先（DFS）    | O(n)       | O(h)       | 空间更优（h为树高）      |

## 题目模式总结
这道题揭示了树遍历类问题的两个核心思路：
1. **层序维度处理**：使用BFS逐层扫描，适合需要处理层级信息的场景
2. **深度优先优化**：通过遍历顺序控制（先右后左）和深度记录实现高效访问

同类问题扩展：
- 二叉树的左视图
- 二叉树的最小深度
- 二叉树的层平均值

解决这类问题的通用思路：
1. 判断是否需要层级信息
2. 选择遍历顺序（BFS保证层级顺序，DFS通过顺序控制优化）
3. 根据问题需求记录特定节点（首/末个节点、最值等）

## 小结
通过这道题，我们掌握了两种观察二叉树的新视角：物理上的右侧视图，算法上的层序与深度优先双解法。就像城市规划师需要多角度观察建筑，优秀的算法工程师也应该掌握多种解题视角。

记住：BFS像用广角镜头捕捉层级全景，DFS像用长焦镜头深入探索细节。根据问题特点选择合适的"镜头"，才能拍出最优美的算法画卷。

---

作者：忍者算法  
公众号：忍者算法

我整理了二叉树相关的20道高频面试题，包含前中后序遍历、重构二叉树、最近公共祖先等经典题型。公众号后台回复【二叉树专题】获取完整题库和解析，助你彻底攻克树类算法难题！